#!/usr/bin/env bash
set -euo pipefail +o history

usage() {
	cat << EOF
Usage: $(basename "$0") [--recalc] PDB
	Minimise energy of i-motif PDB to 100 kJ/mol
	This generates a file with suffix _em100.gro

	Options:
	--recalc	ignore existing .gro files and restart all calculations
EOF
exit
}

[[ $# -eq 0 ]] && usage

pdb=$1

# TODO: detect GPU availability at script start; implement this whenever error occurs

# helper functions {{{

trap "terminate i" INT
trap "terminate e" ERR
# trap finish EXIT

SEP=$(printf %"$(tput cols)"s | tr " " "#")

terminate() {
	# there's probably a way to detect signal
	# https://stackoverflow.com/a/2183063
	if [[ $1 = i ]]; then
		echo "Terminated after ${SECONDS}s at task $n: $task"
	else
		echo "Error after ${SECONDS}s at task $n: $task"
	fi
	tail "$log"
	exit 1
}

finish() {
	start_task "all tasks finished"
	echo ----------------------------- >> "$log"
	msg="Finished $n tasks in ${SECONDS}s with no errors:"
	echo "$msg"
	tail "$log"
	notify-send "$(basename "$0")" "$msg"
	rm -f ./#*
	# rm -f ./step*
	find -iname '*_em*' | grep -Fv 'em100.' | xargs rm -v
	exit 0
}

skip_if_exists() {
	# if --recalc is not given and the file exists (usually .gro), the task
	# is skipped
	# return 1 kills script and necessitates cumbersome "|| return 0"
	[[ -z ${RE:-} ]] && [[ -f $1 ]] && return 1
}

start_task() {
	if [[ -z ${n:-} ]]; then
		n=1
	else
		((n+=1))
	fi

	task=$1
	[[ -n ${2:-} ]] && task="$task; $2"
	t=$(date -Iseconds)

	notify-send "$n [${SECONDS}s]" "$task"
	msg="$n - $t [${SECONDS}s]: $task"
	echo "$msg" >> "$log"

cat <<EOF 

$SEP
# $msg 
$SEP

EOF
	
}

delete_files() {
	# https://unix.stackexchange.com/a/153863
	find -name '#*' -exec rm {} \;
	# find . ! -name "$(basename "$0")" -type f -exec rm -f {} +
	echo "Deleted all backup files"
}

# this assumes that the only important files are .gro
if [[ ${1:-} = --recalc ]]; then
	echo "All existing .gro files will be deleted and calculations will be restarted."
	read -r -n 1 p 'Proceed? [y/N] ' ans </dev/tty
	if [[ ${ans:-} = y ]]; then
		find -name '*.gro' -exec rm {} \;
	else
		exit 1
	fi
fi

if command -v gmx_mpi >/dev/null; then
	GMX=gmx_mpi
else
	GMX=gmx
fi

pwd=$(pwd)

# if [[ $(hostname) = oceanids ]] && [[ $pwd != /scratch* ]]; then
# 	echo "Will not run from $pwd; run from /scratch instead"
# 	# TODO cd there
# 	exit 1
# fi
#}}}

# filename declarations

log=log
# rm -f "$log"

rm -f ./#*

# reference file for chain B required
refb=topol_Other_chain_B.dat
if ! [[ -f $refb ]]; then
	echo "$refb missing!"
	exit 1
fi

md5b=$(< $refb md5sum | cut -d' ' -f1)
if [[ $md5b != 0db43eedf298647de56b7d48a5c3adc8 ]]; then
	cat <<EOF
$refb appears to be incorrect!
Current md5:  $md5b
Expected md5: 0db43eedf298647de56b7d48a5c3adc8
EOF
exit 1
fi

# # probably an overkill check
# # https://unix.stackexchange.com/a/35834
# amber=$(find amber99sb-ildn+slipid_tmx.ff/ -type f -exec md5sum {} \; | sort -k 2 | md5sum | cut -d' ' -f1)
# if [[ $amber != 65713dcd3f7e64b3c650e4f17ecce3bc ]]; then
# 	cat <<EOF
# $amber
# Current md5:  $amber
# Expected md5: 65713dcd3f7e64b3c650e4f17ecce3bc 
# Errors may occur
# EOF
# fi

# this file must be in base dir, apparently
cp "./amber99sb-ildn+slipid_tmx.ff/residuetypes.dat" .

TOP="${pdb/.pdb/.top}" # written to topol.top by default
COMPLEX=${pdb/.pdb/_complex.gro}
BOX=${pdb/.pdb/_box.gro}
SOLV=${pdb/.pdb/_solv.gro}
IONS=${pdb/.pdb/_solv_ions.gro}

em100=${pdb/.pdb/_em100.gro}
UNBOUND=${em100/.gro/_UNBOUND.gro}

IONS_MDP=mdp/ions.mdp
MINIM_MDP=mdp/minim.mdp

if [[ -f "$em100" ]]; then
	read -rp "$em100 already exists; proceed? [y/N] " ans < /dev/tty
	[[ $ans != y ]] && exit
fi

TOPO() {
	# make topology with custom amber force field, TIP3P water. if
	# successful, this generates topol.top, topol_DNA_chain_A.itp and
	# topol_Other_chain_B.itp. the latter is generated incorrectly and must
	# be replaced by a more correct one (published).
	#
	# in the CG case, i think we just use the .top generated by martinize,
	# and we skip this step

	# .top = system topology (starts with includes and [ system ])
	# .rtp = residue topology (starts with [ bondedtypes ])
	# .itp = include topology (starts with [ moleculetype ], can have their own includes)
	#
	# topol.top will then contain a bunch of includes from amber
	# (forcefield, tip3p, ions) and the 2 chain-specific itps

	# # include the CG itps in amber
	# # but this doesn't seem to work
	# ITPS=(
	# 	martini_v2.1-dna.itp
	# 	martini_v2.0_ions.itp
	# 	Nucleic_A.itp
	# )
	# for ITP in ${ITPS[@]}; do
	# 	if ! < "amber99sb-ildn+slipid_tmx.ff/forcefield.itp" grep "$ITP"; then
	# 		echo "#include \"../$ITP\"" >> "amber99sb-ildn+slipid_tmx.ff/forcefield.itp"
	# 	fi
	# done

	# note: pdb2gmx is NOT done in the CG tutorial
	# i.e. they immediately use editconf on the PDB
	#
	# TODO:
	# Fatal error:
	# Atom BB2 in residue DC 2 was not found in rtp entry DC5 with 28 atoms
	# while sorting atoms.
	#
	# i just skipped this

	# [[ -f "complex.gro" ]] && return
	start_task "define topology (fix other chain B)"
	$GMX pdb2gmx -f $pdb -ff amber99sb-ildn+slipid_tmx -water tip3p -o $COMPLEX 
	cp $refb topol_Other_chain_B.itp

	# hopefully this won't cause issues at the npt/md stage
	mv topol.top $TOP
}

# these next 2 steps seem to work fine

# gmx_mpi editconf -f "$CG_PDB" -d 1.2 -bt dodecahedron -o box.gro

UNITCELL() {
	# [[ -f "newbox.gro" ]] && return
	# limit the size of the system to a box of 10 angstroms (?)

	BOXARGS=( -center 5 5 5 -box 10 10 10 )
	start_task "define unit cell" "params: ${BOXARGS[*]}"

	$GMX editconf -f $COMPLEX "${BOXARGS[@]}" -o $BOX
}

# gmx_mpi solvate -cp box.gro -cs water.gro -radius 0.22 -maxsol 1250 -o bw.gro

SOLV() {
	# [[ -f "solv.gro" ]] && return
	# physically place the DNA in water
	# note: the faulty CG .top can actually be read here with no errors

	start_task "solvate"

	# $GMX solvate -cp newbox.gro -cs spc216.gro -p topol.top -o solv.gro
	$GMX solvate -cp $BOX -cs spc216.gro -p "$TOP" -o $SOLV
}

# maxwarn is required to suppress the following warning
# WARNING 1 [file topol.top, line 48]:
#   You are using Ewald electrostatics in a system with net charge. This can
#   lead to severe artifacts, such as ions moving into regions with low
#   dielectric, due to the uniform background charge. We suggest to
#   neutralize your system with counter ions, possibly in combination with a
#   physiological salt concentration.

IONS() {
	# [[ -f "solv_ions.gro" ]] && return
	start_task "generate ions"

	# strangely, Nucleic_A.itp (from martinize) is a binary file because of line 70:
	# Sidechain improper dihedrals [binary garbage]
	#
	# this line is literally too long to be read by cpp (grompp)
	# removing heteroatoms still produces this line
	# removing this line turns the file back into text, but gives a different error
	#
	# Fatal error:
	# Invalid dihedral type 145
	#
	# i have no idea what this "dihedral type 145" refers to
	# it could be solv.gro (but unlikely; that column is just atom number)
	#
	#    39SOL    HW1  145   0.077   0.555   0.580
	#
	# or the CG.top (in turn Nucleic_A.itp)
	#
	# 1     3     5      1  145.00000   400 ; DT
	# 2     1     3     5      2  -145.00000    65 ; DT
	# 19    21    23      1  145.00000   400 ; DT
	# 8     7     9    11      2  -145.00000    65 ; DT
	# 14    13    15    17      2  -145.00000    65 ; DT
	# 20    19    21    23      2  -145.00000    65 ; DT
	#
	# this 145 might have been in the faulty line that i deleted
	# but this is unlikely because the line cannot be hexdump'd
	#
	# martinize-dna.py has not been updated since 2015
	# v2.2, 7c6e2e813067643252651867a9c0882d
	# martini 3 relies on martinize2 (updated 2021), which doesn't have dna force fields yet
	# martini 3 tutorials are so far only for small molecules
	# https://github.com/marrink-lab/vermouth-martinize/issues/370

	$GMX grompp -maxwarn 999 -f $IONS_MDP -c $SOLV -p "$TOP" -o ions.tpr

	# add ions to SOL
	echo SOL | $GMX genion -s ions.tpr -p "$TOP" -pname NA -nname CL -neutral -conc 0.06 -o $IONS
	rm ions.tpr

}

MINIM() {
	# motifXYZ.pdb -> motifXYZ_em.gro
	# [[ -f "${em}100.gro" ]] && return

	# rm "./em"*
	# TODO: specify energies in a newline-delimited file of temps

	ENERGIES=( 1000 500 300 250 200 150 100 )
	start_task "minimise energy (target: 100)" "steps: ${ENERGIES[*]}"

	for e in ${ENERGIES[@]}; do
		start_task "minimise energy (current: $e)"

		em=${pdb/.pdb/_em$e.tpr}

		# minim.mdp -> minim1000.mdp
		# gromacs does NOT accept file objects, too bad
		# $GMX grompp -maxwarn 999 -f <(< "$minim" sed "/emtol/ s|1000|$e|g") -c $IONS -p "$TOP" -o "$em"

		mtemp=${MINIM_MDP/.mdp/$e.mdp}
		< "$MINIM_MDP" sed "/emtol/ s|1000|$e|g" > "$mtemp"
		$GMX grompp -maxwarn 999 -f "$mtemp" -c $IONS -p "$TOP" -o "$em"
		
		# set -pin ... to use GPU 1 locally
		# -deffnm should not contain extension
		# CPU = 20 mins / GPU = 4 mins (usage ~ 350 MB)
		$GMX mdrun -v -deffnm "${em/.tpr/}" -pin on -pinoffset 32 -gpu_id 1
		rm "$mtemp"
	done

	# displace ligand from DNA (along z); assume starting config is bound
	# https://stackoverflow.com/a/49960320
	# https://stackoverflow.com/a/44754982

	awk -F '[ ]' '{if ($0 ~ /RAU/) {$NF=$NF+2;print} else {print}}' "$em100" > "$UNBOUND"

	# .tpr + .trr files might be necessary for trjconv

}

TEMPLATE() {

	start_task "make pdb template"

	em100_pdb=${em100/.gro/.pdb}
	TRR=${em100/.gro/.trr}
	TPR=${em100/.gro/.tpr}
	PDB_TEMPLATE=${em100/.gro/_template.pdb}

	# see ../md_functions.sh :: mkpdb
	echo non-Water non-Water | gmx_mpi trjconv -f $TRR -s $TPR -pbc mol -center -o "$em100_pdb"
	< "$em100_pdb" grep -P '(CRYST| A  |END)' | grep -v H > "$PDB_TEMPLATE" 

}

TOPO
UNITCELL
SOLV
IONS
MINIM
TEMPLATE
finish

# from here on, use md_multitemp.sh instead!

NPT() {
	[[ -f "npt.gro" ]] && return
	start_task "equilibrate (npt)"		# nvt not necessary
	$GMX grompp -maxwarn 999 -f npt.mdp -c em100.gro -p topol.top -r em100.gro -o npt.tpr
	$GMX mdrun -v -deffnm npt
}

# tested with short md (1 ns); TMX "clipped"
# with em100.gro, run npt/md loop at different temperatures (300 350 400 450)
# npt ref_t, gen_temp
# md ref_t
# plumed TEMP
# mkdir for each temp -- e.g. temp$t/npt

NPT

# http://www.mdtutorials.com/gmx/umbrella/Files/get_distances.sh

# trjconv may still be needed with MD
# start_task "get distances"
# echo 0 | $GMX trjconv -s pull.tpr -f pull.xtc -o conf.gro -sep
# rm -f summary_distances.dat
# for (( i=0; i <= 500; i++ )); do
# 	# consider >/dev/null
# 	$GMX distance -s pull.tpr -f "conf${i}.gro" -n index.ndx -select 'com of group "Chain_A" plus com of group "Chain_B"' -oall "dist${i}.xvg"
# 	d=$(tail -n1 "dist${i}.xvg" | awk '{print $2}')
# 	echo "${i}	${d}" | tee -a summary_distances.dat
# 	rm "dist${i}.xvg"
# done

# sample output:
# frame distance
# 0	1.7079545
# ...
# 68	1.9032675
# ...

# http://www.mdtutorials.com/gmx/umbrella/Files/setup-umbrella-script.tar.gz
# (writing python to do such a simple task is a bit silly imo)
# identify configurations with 0.2 nm spacing
# n configurations along the reaction coordinate = n different input files for n independent simulations
# for 501 frames, this n is about 23

start_task "select frames"
< summary_distances.dat head -1 | tee selected_distances.dat
while IFS=$'\t' read -r frame dist; do
	prev_dist=$(< selected_distances.dat tail -1 | cut -f2)
	diff=$(echo "$dist - $prev_dist - 0.2" | bc -l)
	[[ $diff != "-"* ]] && echo "$frame	$dist" | tee -a selected_distances.dat
done < summary_distances.dat

sed -r -i '/^$/d' selected_distances.dat

start_task "umbrella sampling"
frames=$(< selected_distances.dat wc -l)
for (( i=1; i <= "$frames"; i++ )); do
	frame=$(< selected_distances.dat sed -n "${i}p" | cut -f1)

	# in both .mdps, nsteps was reduced from 500k to 50k
	# this caused loop to terminate at run 8 with the following error:
	#
	# ERROR 1 [file npt_umbrella.mdp]:
	# When the maximum distance from a pull group reference atom to other atoms
	# in the group is larger than 0.5 times half the box size a centrally
	# placed atom should be chosen as pbcatom. Pull group 1 is larger than that
	# and does not have a specific atom selected as reference atom.
	#
	# however, for demonstration purposes, the umbrella7.gro/xtc/trr files
	# are good enough for use with vmd

	start_task "umbrella sampling: run $i (frame $frame), npt"
	$GMX grompp -maxwarn 999 -f npt_umbrella.mdp -c "conf$frame.gro" -p topol.top -r "conf$frame.gro" -n index.ndx -o "npt$i.tpr"
	$GMX mdrun -v -deffnm "npt$i"

	start_task "umbrella sampling: run $i (frame $frame), md"
	$GMX grompp -maxwarn 999 -f md_umbrella.mdp -c "npt$i.gro" -t "npt$i.cpt" -p topol.top -r "npt$i.gro" -n index.ndx -o "umbrella$i.tpr"
	$GMX mdrun -v -deffnm "umbrella$i"
done

# extract the potential of mean force (PMF).  ΔG is simply the difference
# between the highest and lowest values of the PMF curve, as long as the values
# of the PMF converge to a stable value at large COM distance.

# it = list of umbrella tpr files
# if = list of pull xvg files

start_task "get wham"
$GMX wham -it tpr-files.dat -if pullf-files.dat -o -hist -unit kCal

# a defect in the PMF profile around ξ = 0.8 nm reflects a lack of sampling.
# This region of ξ is a high-energy state, and since there was no window
# centered on this region of the reaction coordinate, sampling was inadequate.
# To fix this problem, carry out an additional simulation with a window
# centered at ξ = 0.8 nm. As all of the umbrella sampling window simulations
# are independent, the others do not have to be re-run, just include the new
# umbrella.tpr and umbrella_pullf.xvg files in your WHAM input and re-run the
# WHAM analysis.

finish
